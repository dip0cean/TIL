# 원시 값과 객체의 비교

## Primitive Type

- Primitive Type 의 데이터는 변경 불가능한 값(`immutable value`) 이다.
    - Primitive Type 을 변수에 할당하면, 변수(즉, 식별자가 확보한 메모리 공간)에는 실제의 값이 저장된다.
    - Pirmitive Type 의 값을 가지는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다.
    이를 값에 의한 전달 `Pass By Value` 라고 한다.

### *왜 Primitive Type 은 불변할까?*

- 먼저 불변의 주체가 변수를 가리키는지 변수에 할당되는 값을 가리키는지 파악해야한다.
- 변수는 말그대로 값에 대한 **별칭**이므로 어떤 값이든 **재할당하여 변경** 가능하다.
- 하지만 변수에 할당되는 그 **“값(value)”** 은 오직 읽기 전용으로 메모리에 할당되며, 
변수에 새로운 값을 재할당 할 경우 새로운 값에 대한 메모리 공간을 확보하고, 확보한 메모리의 주소를 대상이 되는 변수가 값으로 가진다.
- 즉, 변수의 값이 변경되는 것은 기존의 값 자체가 변경되는 것이 아닌 메모리 주소에서 새로운 값의 메모리 주소를 기존 값으로 대체하여 변수의 값이 변경되는 것 처럼 보이는 것이다.
- 만약 Primitive Type 데이터가 가변성의 특징을 띈다면, 의도치 않게 값이 변경 될 수 있는 가능성이 존재하고, 이는 데이터 추적을 어렵게 만든다.

```jsx
// num 변수는 10 이라는 값이 저장된 메모리 공간의 주소를 값으로 가진다.
let num = 10;

// num 변수에 20 이라는 값으로 재할당하게 되면 20 이라는 값이 저장된 메모리 공간의 주소로 값이 대체된다.
// 만약 10 을 저장하고 있는 메모리를 참조하는 곳이 없다면 GC 에 의해 해당 메모리는 정리된다.
num = 20;
```

### 문자열과 불변성

- C 언어나 자바와는 다르게 자바스크립트에서는 문자열을 Primitive Type 으로도 제공한다.
(자바에서 문자열은 Reference Type 으로 Heap 메모리에 저장되며, 한 번 만들어진 문자열은 별도의 메모리 공간에 저장된다.)
- 자바스크립트에서는 값을 메모리에 저장 할 때, 메모리 공간의 크기를 미리 지정하는데 문자열의 경우 `2byte`, 숫자 타입의 경우 `8byte` 만큼의 메모리 공간을 확보한다. 
다만 다른 타입의 경우 브라우저의 엔진에 따라 확보하는 공간의 크기가 다르다는 것을 인지하고 있자.
- 자바스크립트의 문자열은 0개 이상의 문자(Character) 로 이루어져 있는 집합을 의미하는데, 이는 유사 배열이며, 이터러블이므로 배열과 유사하게 각 문자에 접근 할 수 있다.
- 즉, `“Hello”` 라는 문자열을 변수에 할당할 때, 각 문자들은 `2byte` 의 메모리 공간을 가지게 되고 각 메모리 공간을 배열처럼 이어서 변수에 할당한다.
- 또한, 문자열은 Primitive Type 으로 값 변경이 불가능한 `immutable` 한 데이터이다.
즉, 변수에 새로운 문자열로 재할당 할 경우 재할당 될 문자열이 새로운 메모리 공간을 확보하고 해당 메모리 주소가 변수의 값으로 새롭게 대체된다.

```jsx
let hello = "안녕하세요"; // 각 문자마다 2byte 의 메모리 공간을 가진다.

// 새로운 문자열로 재할당 할 경우 "안녕하세요" 문자열의 각 문자 값이 변경되는 것이 아니다.
// 새로운 문자열은 메모리 공간을 확보하고, 해당 주소는 대상이 되는 변수의 값에 대체된다.
// 즉, 메모리에는 "Hello" 와 "안녕하세요" 두 문자열이 존재하게 된다.
hello = "Hello";

/*
	유사 배열 객체?
	문자열의 각 문자는 개별적인 메모리 공간을 가지고 있으므로 배열과 비슷한 구조를 가지게 된다.
	즉, 배열처럼 인덱스를 사용해 문자열에 특정 인덱스에 위치한 문자에 직접 접근 할 수 있으며,
	문자열의 총 길이를 조회하거나 for 문을 통해 순회를 돌 수 있다.
*/

console.log(hello[0]); // "H" 출력

// Auto Casting 을 통해 String() 참조 객체로 자동으로 캐스팅되어 객체처럼 작동하여
// 객체에 존재하는 함수들을 사용 할 수 있다.
console.log(hello.length); // 5
console.log(hello.toLowerCase()); // hello
```

### 값에 의한 전달

- 자바스크립트에서는 Primitive  Type 의 값이 할당된 변수를 다른 변수에 할당하는 경우,
대상이 되는 변수 자체를 하나의 표현식으로 바라보기 때문에 
**대상 변수가 참조하고 있는 데이터의 메모리 주소에 존재하는 값을 새로운 메모리 공간에 할당하고 해당 메모리 주소를 복사본 변수의 값으로 할당한다.**
- 즉, 이러한 값의 전달이 대상 변수가 값으로 가지고 있는 메모리 주소 그대로 복사본 변수의 값으로 할당하는 것이 아니다.
- 그렇기 때문에 대상 변수와 복사본 변수의 실질적인 데이터는 같을지라도, **각 데이터가 저장된 메모리 주소는 다르다. 그러므로 대상 변수와 복사본 변수의 데이터는 다른 데이터이다.**
결국 대상 변수와 복사본 변수의 원시 값은 서로 다른 메모리 공간에 저장된 각기 다른 값이기 때문에 어느 한 쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭 할 수 없다.

```jsx
let age = 100;
let copy = age;

console.log(age, copy); // 100, 100
console.log(age === copy); // true > 데이터는 같지만 서로 저장된 메모리 주소는 다르다.

// 200 이라는 값을 새로운 메모리 공간을 확보하고 해당 메모리의 주소를 age 변수의 값에 재할당한다.
age = 200;

console.log(age, copy); // 200, 100
console.log(age === copy); // false
```

## Reference Type

- Reference Type 의 데이터는 변경 가능한 값(`mutable value`) 이다.
    - Reference Type 을 변수에 할당하면, 변수에는 값이 저장된 메모리 주소가 저장된다. 즉, 값이 실제로 존재하는 메모리 공간을 참조하게 된다는 의미이다.
    - Reference Type 의 값을 가지는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달된다. 즉, 복사되는 변수는 대상이 되는 객체의 메모리 주소를 기존 변수와 함께 참조하게 된다는 의미이다.
    이를 참조에 의한 전달 `Pass By Reference` 라고 한다.
